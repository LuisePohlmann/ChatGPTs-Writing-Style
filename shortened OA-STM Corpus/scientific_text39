Using SPIN for automated debugging of infinite executions of Java programs  Highlights • We use linear time temporal logic to represent both failures and desirable behaviors regarding a temporally ordered sequence of events and/or conditions to be checked along one execution. • We use model checking algorithms record the history of the failed execution, which we use to implement a controlled replay to locate the bugs. • We support the analysis of potentially infinite executions. • We use runtime techniques to start the debugging work directly on the programmer's code. Abstract This paper presents an approach for the automated debugging of reactive and concurrent Java programs, combining model checking and runtime monitoring. Runtime monitoring is used to transform the Java execution traces into the input for the model checker, the purpose of which is twofold. First, it checks these execution traces against properties written in linear temporal logic (LTL), which represent desirable or undesirable behaviors. Second, it produces several execution traces for a single Java program by generating test inputs and exploring different schedulings in multithreaded programs. As state explosion is the main drawback to model checking, we propose two abstraction approaches to reduce the memory requirements when storing Java states. We also present the formal framework to clarify which kinds of LTL safety and liveness formulas can be correctly analysed with each abstraction for both finite and infinite program executions. A major advantage of our approach comes from the model checker, which stores the trace of each failed execution, allowing the programmer to replay these executions to locate the bugs. Our current implementation, the tool TJT, uses Spin as the model checker and the Java Debug Interface (JDI) for runtime monitoring. TJT is presented as an Eclipse plug-in and it has been successfully applied to debug complex public Java programs.  Introduction The complexity of current software development is pushing programmers towards more automated analysis techniques, instead of the traditional interactive or postmortem debuggers. For instance, unit testing allows the execution of test cases against a program, checking parts of the code such as single methods or classes in isolation (Runeson, 2006; JUnit testing and framework, xxxx; Beust and Suleiman, 2007; CppUnit framework, xxxx). Runtime monitoring tools usually carry out some controlled executions of instrumented code on real or emulated target platforms (Run-time Monitoring and Checking, (MaC), xxxx; Kraft et al., 2010). Model checking can produce and inspect all possible execution traces of a program, checking the presence or absence of failures along each trace (Clarke et al., 1999; Havelund and Pressburger, 2000; Beyer et al., 2007). In the case of a failure, this technique records a trace to replay the failed execution. To overcome some of the shortcomings of these automatic methods when used in isolation and to extend their domain of application, there have been several proposals that combine a few of them (Peled, 2003; Artho et al., 2003; Havelund and Roşu, 2004). This paper discusses an approach to automated software debugging by the combination of model checking and runtime monitoring. We focus on its application to analyze the (infinite) executions of a given reactive and/or concurrent Java program. Model checking allows the software developer to describe correctness properties with specification languages such as Temporal Logic (Manna and Pnueli, 1992). The properties could represent safety requirements, like □p ("p is always true") and p U q ("q will be true, and p will be true in all previous states"), or liveness properties expressed with formulas such as ◊p ("eventually p will be true"), ◊□p ("eventually p will be true forever"), and □(p→◊q) ("p will always be followed by q"), p and p being any kind of proposition or even temporal formulas. The most common use of LTL is to express complex liveness behaviors of infinite traces, which are the traces produced by reactive and/or concurrent software (Manna and Pnueli, 1992). In order to check whether or not a program satisfies an LTL formula, model checking algorithms were designed to produce the whole execution graph in a concurrent program and to efficiently detect execution traces violating a formula, presenting these traces as counter-examples. Counter-examples provide the sequence of instructions to the error, and they are the main source of information used to debug the program. When we do not wish to produce all traces or check liveness properties, other less-expensive approaches, like the use of runtime monitors can be used to check only the subset of LTL representing safety properties. Other monitor based approaches adapt the semantics of full LTL to finite executions, as done by Java PathExplorer (Havelund and Roşu, 2004). The original design of Java PathExplorer only considered finite executions, and to the best of our knowledge, the extension for infinite traces is still not available. Tools such as Verisoft (Godefroid, 1997) and CMC (Stoller, 2002) avoid storing the states of the program during monitoring, so they can perform a partial analysis of very large systems with little memory consumption. Unfortunately, this stateless approach does not permit the analysis of LTL for infinite traces. The analysis of an LTL formula along one or several potential infinite execution paths cannot be carried out with standard monitors, but requires storing the states of the program and the use of algorithms based on automata to recognize special cycles, like Büchi automata (Clarke et al., 1999). Stateful approaches, like the one implemented in Java PathFinder (Visser et al., 2003) (JPF) keep a stack with the current execution trace to control backtracking, to produce counter-examples and to check cycles, so they could check LTL on infinite traces. However, at the time of writing this paper, the extension for checking LTL formulas can only detect a few program events. In the following sections we expand on the current status of LTL verification with JPF in a comparison with our proposal. In this paper we propose a method to convert a Java execution trace into a sequence of states that can be analyzed by the model checker Spin (Holzmann, 2003). We use runtime monitoring to generate just the Spin oriented execution paths from real software, thereby allowing the formulas to be evaluated by Spin. Our work focuses on two major issues of software model checking, analysis of infinite executions and efficient abstraction of execution paths. As Spin implements the analysis of LTL formulas by translation to Büchi automata, thanks to our method to feed Java executions to Spin as input, we can check the formulas on Java programs with infinite cycles. Furthermore, the Spin stuttering mechanism for dealing with finite execution traces allows us to deal with any kind of program without redefining the original LTL semantics. In order to address the second issue, the abstraction of execution paths, our conversion of Java traces into Spin oriented traces is based on two efficient abstraction methods of the full state of the program. The counter projection abstracts the Java state by preserving the variables which appear in the LTL formula and adding a counter to distinguish the rest of the state. As we do not keep all the information, the counter projection is very efficient at the cost of being useful only for finite executions. The hash projection abstracts each Java state with the variables in the formula plus a hash of the whole state. The way of constructing the hash makes the probability of conflict for two different states negligible, so we can rely on the Spin algorithm to check LTL based on cycle detection. The paper provides a formal study of the correctness of both abstraction methods. We have implemented the proposed approach in TJT, a tool that combines runtime monitoring and model checking and allows Java application developers to debug programs by checking complex requirements represented with temporal logic in a transparent way: the actual Java program is analyzed on the final target platform without additional modifications by the user, while the test execution is managed in the usual integrated development environment. Specifically, we combine the Spin model checker (Holzmann, 2003) and the runtime debugging API Java Debug Interface (JDI) (Java Platform Debugger Architecture, xxxx). Checking each execution means evaluating a temporal formula representing a failure, over the observable states in the program. Such observable states are provided for Spin by a runtime monitoring module built on top of the JDI support in the Java virtual machine. Both modules are integrated as a new Eclipse (Eclipse development environment, xxxx) plug-in for automatic debugging. TJT stores the failed executions, so that the programmer can later replay them in Eclipse to locate and fix the bugs. 